using System;
using System.Linq;

using osu.Framework.Allocation;
using osu.Framework.Graphics.Primitives;
using osu.Framework.Graphics.Rendering;
using osu.Framework.Graphics.Sprites;
using osu.Framework.Graphics;
using osu.Framework.Input;

using osuTK;
using osu.Framework.Utils;

namespace ZeroV.Game.Tests.Visual.Screens;

/// <summary>
/// Draws a pentagon.
/// </summary>
/// <remarks>
/// NOTE: This is a piece of code generated by Claude to verify its model capabilities. In order to aid understanding of osu!framework that lack documentation.
/// </remarks>
public partial class Pentagon : Sprite, ISourceGeneratedDependencyActivator, ISourceGeneratedHandleInputCache, ISourceGeneratedLongRunningLoadCache {

    private class PentagonDrawNode(Pentagon source) : SpriteDrawNode(source) {
        protected override void Blit(IRenderer renderer) {
            if (this.DrawRectangle.Width != 0f && this.DrawRectangle.Height != 0f) {
                Triangle[] triangles = toPentagonTriangles(this.ScreenSpaceDrawQuad);
                foreach (Triangle triangle in triangles) {
                    renderer.DrawTriangle(this.Texture, triangle, this.DrawColourInfo.Colour,
                        textureRect: null, vertexAction: null,
                        inflationPercentage: new Vector2(this.InflationAmount.X / this.DrawRectangle.Width, this.InflationAmount.Y / this.DrawRectangle.Height),
                        textureCoords: this.TextureCoords);
                }
            }
        }

        protected override void BlitOpaqueInterior(IRenderer renderer) {
            if (this.DrawRectangle.Width != 0f && this.DrawRectangle.Height != 0f) {
                Triangle[] triangles = toPentagonTriangles(this.ConservativeScreenSpaceDrawQuad);
                for (var i = 0; i < triangles.Length; i++) {
                    Triangle triangle = triangles[i];
                    if (renderer.IsMaskingActive) {
                        renderer.DrawClipped(ref triangle, this.Texture, this.DrawColourInfo.Colour);
                    } else {
                        renderer.DrawTriangle(this.Texture, triangle, this.DrawColourInfo.Colour);
                    }
                }
            }
        }
    }

    public override RectangleF BoundingBox => calculateBoundingBox(this.ToParentSpace(this.LayoutRectangle));

    Type ISourceGeneratedHandleInputCache.KnownType => typeof(Pentagon);
    Type ISourceGeneratedLongRunningLoadCache.KnownType => typeof(Pentagon);

    public Pentagon() {
        this.Size = Vector2.One;
    }

    [BackgroundDependencyLoader]
    private void load(IRenderer renderer) {
        this.Texture ??= renderer.WhitePixel;
    }

    private static Triangle[] toPentagonTriangles(Quad q) {
        Vector2 center = q.Centre;
        var radius = Math.Min(q.Width, q.Height) / 2;
        Vector2[] vertices = new Vector2[5];

        for (var i = 0; i < 5; i++) {
            var angle = 2 * Math.PI / 5 * i - Math.PI / 2;
            vertices[i] = new Vector2(
                (Single)(center.X + radius * Math.Cos(angle)),
                (Single)(center.Y + radius * Math.Sin(angle))
            );
        }

        return [
            new Triangle(center, vertices[0], vertices[1]),
            new Triangle(center, vertices[1], vertices[2]),
            new Triangle(center, vertices[2], vertices[3]),
            new Triangle(center, vertices[3], vertices[4]),
            new Triangle(center, vertices[4], vertices[0])
        ];
    }

    private static RectangleF calculateBoundingBox(Quad q) {
        Triangle[] triangles = toPentagonTriangles(q);
        Single minX = Single.MaxValue, minY = Single.MaxValue;
        Single maxX = Single.MinValue, maxY = Single.MinValue;

        foreach (Triangle triangle in triangles) {
            minX = Math.Min(minX, Math.Min(triangle.P0.X, Math.Min(triangle.P1.X, triangle.P2.X)));
            minY = Math.Min(minY, Math.Min(triangle.P0.Y, Math.Min(triangle.P1.Y, triangle.P2.Y)));
            maxX = Math.Max(maxX, Math.Max(triangle.P0.X, Math.Max(triangle.P1.X, triangle.P2.X)));
            maxY = Math.Max(maxY, Math.Max(triangle.P0.Y, Math.Max(triangle.P1.Y, triangle.P2.Y)));
        }

        return new RectangleF(minX, minY, maxX - minX, maxY - minY);
    }

    public override Boolean Contains(Vector2 screenSpacePos) {
        return toPentagonTriangles(this.ScreenSpaceDrawQuad).Any(t => t.Contains(screenSpacePos));
    }

    protected override DrawNode CreateDrawNode() {
        return new PentagonDrawNode(this);
    }

    public override void RegisterForDependencyActivation(IDependencyActivatorRegistry registry) {
        if (!registry.IsRegistered(typeof(Pentagon))) {
            base.RegisterForDependencyActivation(registry);
            registry.Register(typeof(Pentagon), (t, d) => {
                ((Pentagon)t).load(SourceGeneratorUtils.GetDependency<IRenderer>(d, typeof(Pentagon), null, null, false, false));
            }, null);
        }
    }
}
